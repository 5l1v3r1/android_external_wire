package com.squareup.wire.compiler.plugin.java;

import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.collect.FluentIterable;
import com.squareup.javawriter.JavaWriter;
import com.squareup.protoparser.ExtendDeclaration;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.Type;
import com.squareup.wire.compiler.plugin.WirePlugin;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Set;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.squareup.wire.compiler.plugin.java.JavaUtil.PUBLIC_FINAL;
import static com.squareup.wire.compiler.plugin.java.JavaUtil.PUBLIC_STATIC_FINAL;
import static com.squareup.wire.compiler.plugin.java.JavaUtil.emitNoInstanceConstructor;

public class WireJavaPlugin implements WirePlugin {
  private static final String HEADER = "Generated by Wire Java plugin. Do not modify!";

  private Path outputDirectory;
  private String registryClass;
  private boolean generateOptions = true;
  private NamingConvention namingConvention = new NamingConvention.Default();

  /** Directory into which generated code will be placed. */
  public WireJavaPlugin setOutputDirectory(Path outputDirectory) {
    checkNotNull(outputDirectory, "Output directory must not be null.");
    this.outputDirectory = outputDirectory;
    return this;
  }

  /**
   * A fully-qualified Java class name which will be generated containing a constant list of all
   * extension classes. This list is suitable for passing to
   * {@link com.squareup.wire.Wire#Wire(List) Wire's constructor} at runtime for constructing its
   * internal extension registry.
   */
  public WireJavaPlugin setRegistryClass(String registryClass) {
    checkNotNull(registryClass, "Registry class must not be null.");
    checkArgument(!registryClass.trim().isEmpty(), "Registry class must not be blank.");
    this.registryClass = registryClass;
    return this;
  }

  /**
   * Control whether code will be emitted for options on messages and fields. The presence of
   * options on a message will result in a static member named {@code MESSAGE_OPTIONS}, initialized
   * with the options and their values. The presence of options on a field (other than the standard
   * options "default", "deprecated", and "packed") will result in a static member named
   * {@code FIELD_OPTIONS_&lt;field name>} in the generated code, initialized with the field option
   * values.
   */
  public WireJavaPlugin setGenerateOptions(boolean generateOptions) {
    this.generateOptions = generateOptions;
    return this;
  }

  /**
   * Specify the naming convention that will be used when converting from various protocol buffer
   * names to their corresponding Java names.
   */
  public WireJavaPlugin setNamingConvention(NamingConvention namingConvention) {
    checkNotNull(namingConvention, "Naming convention must not be null.");
    this.namingConvention = namingConvention;
    return this;
  }

  @Override public final void generate(Set<ProtoFile> protoFiles) throws IOException {
    checkState(outputDirectory != null, "Output directory is required.");
    Files.createDirectories(outputDirectory);

    for (ProtoFile protoFile : protoFiles) {
      generateProtoFile(protoFile);
    }

    if (registryClass != null) {
      int lastIndexOf = registryClass.lastIndexOf('.');
      String registryPackage = registryClass.substring(0, lastIndexOf);
      String registryClassName = registryClass.substring(lastIndexOf + 1);
      try (JavaWriter writer = JavaUtil.newJavaWriter(outputDirectory, registryPackage,
          registryClassName)) {
        emitRegistryClass(writer, registryPackage, registryClassName, protoFiles);
      }
    }
  }

  private void generateProtoFile(ProtoFile protoFile) throws IOException {
    String packageName = JavaUtil.getPackageName(protoFile);

    for (Type type : protoFile.getTypes()) {
      String name = type.getName();
      try (JavaWriter writer = JavaUtil.newJavaWriter(outputDirectory, packageName, name)) {
        emitTypeHeader(writer, packageName);
        emitType(writer, type, true);
      }
    }

    for (ExtendDeclaration extendDeclaration : protoFile.getExtendDeclarations()) {
      String typeName = namingConvention.getExtendDeclarationName(extendDeclaration.getName());
      try (JavaWriter writer = JavaUtil.newJavaWriter(outputDirectory, packageName, typeName)) {
        emitExtendDeclaration(writer, packageName, typeName, extendDeclaration);
      }
    }
  }

  private void emitTypeHeader(JavaWriter writer, String packageName) throws IOException {
    writer.emitSingleLineComment(HEADER);
    if (packageName != null) {
      writer.emitPackage(packageName);
      writer.emitEmptyLine();
    }
  }

  private void emitType(JavaWriter writer, Type type, boolean root) throws IOException {
    writer.beginType(type.getName(), "class", root ? PUBLIC_FINAL : PUBLIC_STATIC_FINAL);
    writer.emitSingleLineComment("TODO");

    for (Type nestedType : type.getNestedTypes()) {
      emitType(writer, nestedType, false);
    }

    writer.endType();
  }

  private void emitExtendDeclaration(JavaWriter writer, String packageName, String typeName,
      ExtendDeclaration extendDeclaration) throws IOException {
    writer.emitSingleLineComment(HEADER);
    if (packageName != null) {
      writer.emitPackage(packageName);
      writer.emitEmptyLine();
    }

    writer.beginType(typeName, "class", PUBLIC_FINAL);
    writer.emitSingleLineComment("TODO");
    writer.endType();
  }

  private void emitRegistryClass(JavaWriter writer, String registryPackage,
      String registryClassName, Set<ProtoFile> protoFiles) throws IOException {
    writer.emitSingleLineComment(HEADER);
    writer.emitPackage(registryPackage);
    writer.emitEmptyLine();

    writer.emitImports("java.util.List");
    writer.emitEmptyLine();
    writer.emitStaticImports("java.util.Arrays.asList", "java.util.Collections.unmodifiableList");
    writer.emitEmptyLine();

    writer.beginType(registryClassName, "class", PUBLIC_FINAL);

    Iterable<String> names = FluentIterable.from(protoFiles)
        .transformAndConcat(new Function<ProtoFile, Iterable<ExtendDeclaration>>() {
          @Override public Iterable<ExtendDeclaration> apply(ProtoFile protoFile) {
            return protoFile.getExtendDeclarations();
          }
        })
        .transform(new Function<ExtendDeclaration, String>() {
          @Override public String apply(ExtendDeclaration extendDeclaration) {
            // TODO should be Ext_ prefixed
            return extendDeclaration.getFullyQualifiedName() + ".class";
          }
        });
    String nameList = "unmodifiableList(asList(\n" + Joiner.on(",\n").join(names) + "))";

    writer.emitAnnotation(SuppressWarnings.class, "\"unchecked\"");
    writer.emitField("List<Class<?>>", "EXTENSIONS", PUBLIC_STATIC_FINAL, nameList);
    writer.emitEmptyLine();

    emitNoInstanceConstructor(writer);

    writer.endType();
  }
}
