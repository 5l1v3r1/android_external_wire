package com.squareup.wire.compiler.plugin.java;

import com.squareup.javawriter.JavaWriter;
import com.squareup.protoparser.EnumType;
import com.squareup.protoparser.ExtendDeclaration;
import com.squareup.protoparser.MessageType;
import com.squareup.protoparser.Option;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.Service;
import com.squareup.protoparser.Type;
import com.squareup.wire.ProtoEnum;
import com.squareup.wire.ProtoField;
import com.squareup.wire.compiler.parser.AllTypesVisitor;
import com.squareup.wire.compiler.parser.WireParser;
import com.squareup.wire.compiler.plugin.WireCompilerException;
import com.squareup.wire.compiler.plugin.WirePlugin;
import com.squareup.wire.compiler.plugin.java.services.ServiceWriter;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.nio.file.FileSystem;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import javax.lang.model.element.Modifier;
import okio.ByteString;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

public class WireJavaPlugin implements WirePlugin {

  private static final String CODE_GENERATED_BY_WIRE =
      "Code generated by Wire protocol buffer compiler, do not edit.";
  private static final Charset ISO_8859_1 = Charset.forName("ISO_8859_1");

  private static final String URL_CHARS = "[-!#$%&'()*+,./0-9:;=?@A-Z\\[\\]_a-z~]";

  private final Map<String, String> javaSymbolMap = new LinkedHashMap<>();
  private final Set<String> javaSymbols = new LinkedHashSet<>();
  private final OptionsMapMaker optionsMapMaker = new OptionsMapMaker(this);

  private Path outputDirectory;
  private String registryClass;
  private Constructor<?> serviceWriterConstructor;
  private List<String> serviceWriterOptions = new ArrayList<>();
  private List<String> enumOptions = new ArrayList<>();
  private final Map<String, ExtensionInfo> extensionInfo = new LinkedHashMap<>();
  private final Map<String, FieldInfo> fieldMap = new LinkedHashMap<>();
  private boolean generateOptions = true;

  private final IO io = new IO.FileIO();

  /** Directory into which generated code will be placed. */
  public WireJavaPlugin setOutputDirectory(Path outputDirectory) {
    checkNotNull(outputDirectory, "Output directory must not be null.");
    this.outputDirectory = outputDirectory;
    return this;
  }

  public WireJavaPlugin setServiceWriter(String serviceWriter) {
    if (serviceWriter != null) {
      this.serviceWriterConstructor = loadServiceWriter(serviceWriter);
    }
    return this;
  }

  private static Constructor<?> loadServiceWriter(String serviceWriterClassName) {
    Class<?> serviceWriterClass = null;
    try {
      serviceWriterClass = Class.forName(serviceWriterClassName);
    } catch (ClassNotFoundException e) {
      System.err.println("Unable to load ServiceWriter class " + serviceWriterClassName + ".");
      System.exit(1);
    }

    if (!ServiceWriter.class.isAssignableFrom(serviceWriterClass)) {
      System.err.println(
          "Class " + serviceWriterClassName + " does not implement ServiceWriter interface.");
      System.exit(0);
    }

    try {
      return serviceWriterClass.getConstructor(JavaWriter.class, List.class);
    } catch (NoSuchMethodException e) {
      System.err.println("ServiceWriter class "
          + serviceWriterClassName
          + " needs a constructor 'public "
          + serviceWriterClassName
          + "(JavaWriter writer, List<String> options)'.");
      System.exit(1);
    }

    return null;
  }

  public WireJavaPlugin setServiceWriterOptions(String serviceWriterOptions) {
    if (serviceWriterOptions != null) {
      Collections.addAll(this.serviceWriterOptions, serviceWriterOptions.split(","));
    }
    return this;
  }

  /**
   * A fully-qualified Java class name which will be generated containing a constant list of all
   * extension classes. This list is suitable for passing to
   * {@link com.squareup.wire.Wire#Wire(List) Wire's constructor} at runtime for constructing its
   * internal extension registry.
   */
  public WireJavaPlugin setRegistryClass(String registryClass) {
    checkNotNull(registryClass, "Registry class must not be null.");
    checkArgument(!registryClass.trim().isEmpty(), "Registry class must not be blank.");
    this.registryClass = registryClass;
    return this;
  }

  /**
   * Control whether code will be emitted for options on messages and fields. The presence of
   * options on a message will result in a static member named {@code MESSAGE_OPTIONS}, initialized
   * with the options and their values. The presence of options on a field (other than the standard
   * options "default", "deprecated", and "packed") will result in a static member named
   * {@code FIELD_OPTIONS_&lt;field name>} in the generated code, initialized with the field option
   * values.
   */
  public WireJavaPlugin setGenerateOptions(boolean generateOptions) {
    this.generateOptions = generateOptions;
    return this;
  }

  private JavaWriter writer;
  private String javaPackage;
  private Map<String, String> enumTypes;
  String typeBeingGenerated = "";

  @Override public void generate(FileSystem fs, WireParser.ParsedInput parsedInput) {
    // TODO - generate EXT_ file
    // TODO - emit services
    // TODO - pass output dir as a flag
    setOutputDirectory(fs.getPath(System.getProperty("java_out", ".")));
    setServiceWriter(System.getProperty("service_writer"));
    setServiceWriterOptions(System.getProperty("service_writer_opt"));
    this.enumTypes = parsedInput.enumTypes;
    this.enumOptions = parsedInput.enumOptions;

    for (ProtoFile protoFile : parsedInput.protoFiles) {
      populateJavaSymbolMap(protoFile.getTypes(), getJavaPackage(protoFile) + ".");
    }

    new AllTypesVisitor(parsedInput.protoFiles) {
      @Override public void visitExtendDeclaration(ProtoFile protoFile,
          ExtendDeclaration extendDeclaration) {
         addExtension(protoFile, extendDeclaration);
      }

      @Override public void visitMessageType(MessageType messageType) {
        for (MessageType.Field field : messageType.getFields()) {
          String fieldType = field.getType();
          String fqMessageName = messageType.getFullyQualifiedName();
          String key = fqMessageName + "$" + field.getName();
          fieldMap.put(key, new FieldInfo(fieldType, field.getLabel()));
        }
      }
    }.visit();

    for (ProtoFile protoFile : parsedInput.protoFiles) {
      javaPackage = getJavaPackage(protoFile);

      if (hasExtends(protoFile)) {
        try {
          emitExtensionClass(protoFile);
        } catch (IOException e) {
          throw new RuntimeException(e); // fatal
        }
      }

      for (Type type : protoFile.getTypes()) {
        String savedType = typeBeingGenerated;
        typeBeingGenerated += type.getName() + ".";
        try {
          emitMessageClass(protoFile, type);
        } catch (IOException e) {
          throw new RuntimeException(e); // fatal
        }
        typeBeingGenerated = savedType;
      }

      for (Service service : protoFile.getServices()) {
        List<Service.Method> limitedMethods = new ArrayList<>();
        for (Service.Method method : service.getMethods()) {
          limitedMethods.add(method);
        }
        Service limitedService = new Service(service.getName(), service.getFullyQualifiedName(),
            service.getDocumentation(), service.getOptions(), limitedMethods);
        try {
          emitServiceInterface(protoFile, limitedService);
        } catch (IOException e) {
          throw new RuntimeException(e); // fatal
        }
      }
    }
  }

  private void addExtension(ProtoFile protoFile, ExtendDeclaration extend) {
    for (MessageType.Field field : extend.getFields()) {
      String fieldType = field.getType();
      String type = javaName(protoFile, fieldType);
      type = shortenJavaName(protoFile, type);
      String fqName = prefixWithPackageName(protoFile, field.getName());
      String fqType;

      boolean isScalar = TypeInfo.isScalar(fieldType);
      boolean isEnum =
          !isScalar && isEnum(fieldType);
      if (isScalar) {
        type = field.getType();
        fqType = type;
      } else if (isEnum) {
        // Store fully-qualified name for enumerations so we can identify them later
        type = fieldType;
        fqType = type;
      } else {
        fqType = fieldType;
      }

      String location = protoFileName(protoFile.getFileName());
      String fqLocation = getJavaPackage(protoFile) + ".Ext_" + location;
      ExtensionInfo info =
          new ExtensionInfo(type, fqType, location, fqLocation, field.getLabel());
      extensionInfo.put(fqName, info);
    }
  }

  private void emitExtensionClass(ProtoFile protoFile) throws IOException {
    writer = io.getJavaWriter(outputDirectory, javaPackage, "Ext_" +
        protoFileName(protoFile.getFileName()));
    try {
      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", protoFile.getFileName());
      writer.emitPackage(getJavaPackage(protoFile));

      Set<String> imports = new LinkedHashSet<>();
      if (hasByteStringExtension(protoFile)) {
        imports.add("okio.ByteString");
      }
      imports.add("com.squareup.wire.Extension");
      if (hasRepeatedExtension(protoFile)) {
        imports.add("java.util.List");
      }
      List<String> extensionTypes = getExtensionTypes(protoFile);

      if (generateOptions) {
        imports.addAll(extensionTypes);
      } else {
        for (String extensionType : extensionTypes) {
          if (!isOptionType(extensionType)) {
            imports.add(extensionType);
          }
        }
      }
      writer.emitImports(imports);
      writer.emitEmptyLine();

      String className = "Ext_" + protoFileName(protoFile.getFileName());
      writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
      writer.emitEmptyLine();

      // Private no-args constructor
      writer.beginMethod(null, className, EnumSet.of(PRIVATE));
      writer.endMethod();
      writer.emitEmptyLine();

      emitExtensions(protoFile);
      writer.endType();
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void emitExtensions(ProtoFile protoFile) throws IOException {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      String fullyQualifiedName = extend.getFullyQualifiedName();
      if (!generateOptions && isOptionType(fullyQualifiedName)) {
        continue;
      }
      String javaName = javaNameNoScope(protoFile, fullyQualifiedName);
      if (javaName == null) {
        throw new RuntimeException("Unknown type: " + fullyQualifiedName + " (add to roots?)");
      }
      String name = shortenJavaName(protoFile, javaName);
      for (MessageType.Field field : extend.getFields()) {
        String fieldType = field.getType();
        String type;
        if (TypeInfo.isScalar(fieldType)) {
          type = TypeInfo.scalarType(fieldType);
        } else {
          type = javaSymbolMap.get(fieldType);
        }
        type = shortenJavaName(protoFile, type);
        String initialValue;
        String className = writer.compressType(name);
        String extensionName = field.getName();
        String fqName = prefixWithPackageName(protoFile, field.getName());
        int tag = field.getTag();

        boolean isScalar = TypeInfo.isScalar(fieldType);
        boolean isEnum = !isScalar && isEnum(fieldType);
        String labelString = getLabelString(field, isEnum);
        if (isScalar) {
          initialValue = String.format("Extension%n"
              + ".%1$sExtending(%2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", field.getType(), className, fqName, tag, labelString);
        } else if (isEnum) {
          initialValue = String.format("Extension%n"
              + ".enumExtending(%1$s.class, %2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", type, className, fqName, tag, labelString);
        } else {
          initialValue = String.format("Extension%n"
              + ".messageExtending(%1$s.class, %2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", type, className, fqName, tag, labelString);
        }

        if (FieldInfo.isRepeated(field)) {
          type = "List<" + type + ">";
        }
        writer.emitField("Extension<" + name + ", " + type + ">", extensionName,
            EnumSet.of(PUBLIC, STATIC, FINAL), initialValue);
      }
    }
  }

  private void emitMessageClass(ProtoFile protoFile, Type type) throws IOException {
    writer = io.getJavaWriter(outputDirectory, javaPackage, type.getName());
    try {
      TypeInfo typeInfo = new TypeInfo(type, enumTypes.keySet(), generateOptions);

      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", protoFile.getFileName());
      writer.emitPackage(javaPackage);

      Map<String, ?> optionsMap = null;

      Set<String> externalTypes = new LinkedHashSet<>();
      getExternalTypes(type, externalTypes);

      if (generateOptions) {
        if (type instanceof MessageType) {
          optionsMap = optionsMapMaker.createMessageOptionsMap(protoFile, (MessageType) type);
          optionsMapMaker.getOptionTypes(protoFile, optionsMap, externalTypes);

          for (MessageType.Field field : ((MessageType) type).getFields()) {
            Map<String, ?> fieldOptionsMap = optionsMapMaker.createFieldOptionsMap(protoFile,
                (MessageType) type, field.getOptions());
            optionsMapMaker.getOptionTypes(protoFile, fieldOptionsMap, externalTypes);
          }
        }
      }

      emitHeader(typeInfo, externalTypes);
      emitType(protoFile, type, protoFile.getPackageName() + ".", optionsMap, true);
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void emitHeader(TypeInfo typeInfo, Set<String> externalTypes) throws IOException {
    Set<String> imports = new LinkedHashSet<>(typeInfo.getImports());
    imports.addAll(externalTypes);

    writer.emitImports(imports);
    Collection<String> staticImports = typeInfo.getStaticImports();
    if (!staticImports.isEmpty()) {
      writer.emitEmptyLine();
      writer.emitStaticImports(staticImports);
    }
  }

  private static class EnumValueOptionInfo implements Comparable<EnumValueOptionInfo> {
    public final String type;
    public final String name;

    EnumValueOptionInfo(String type, String name) {
      this.type = type;
      this.name = name;
    }

    @Override public int compareTo(EnumValueOptionInfo other) {
      return name.compareTo(other.name);
    }
  }

  private void emitType(ProtoFile protoFile, Type type, String currentType,
      Map<String, ?> optionsMap, boolean topLevel) throws IOException {
    writer.emitEmptyLine();
    if (type instanceof MessageType) {
      emitAll(protoFile, (MessageType) type, optionsMap, topLevel);
      for (Type nestedType : type.getNestedTypes()) {
        emitType(protoFile, nestedType, currentType + nestedType.getName() + ".", optionsMap,
            false);
      }
      writer.endType();
    } else if (type instanceof EnumType) {
      EnumType enumType = (EnumType) type;
      OptionsMapMaker mapMaker = new OptionsMapMaker(this);

      // Generate a list of all the options used by any value of this enum type.
      List<EnumValueOptionInfo> options = getEnumValueOptions(protoFile, enumType, mapMaker);

      writer.beginType(enumType.getName(), "enum", EnumSet.of(PUBLIC), null, "ProtoEnum");
      List<EnumType.Value> values = enumType.getValues();
      List<String> undefinedInitializers = new ArrayList<String>();

      writer.emitJavadoc("Wire-generated value, do not access from application code.");
      if (values.isEmpty()) {
        writer.emitEnumValue("__UNDEFINED__(UNDEFINED_VALUE)", true);
      } else {
        undefinedInitializers.add("UNDEFINED_VALUE");
        addNullEnumValueOptionInitializers(protoFile, values.get(0), options, mapMaker,
             undefinedInitializers);
        writer.emitEnumValue("__UNDEFINED__(" + join(undefinedInitializers, ", ") + ")", false);
      }
      writer.emitEmptyLine();

      for (int i = 0, count = values.size(); i < count; i++) {
        EnumType.Value value = values.get(i);
        emitDocumentation(value.getDocumentation());

        List<String> initializers = new ArrayList<>();
        int tag = value.getTag();
        if (tag == ProtoEnum.UNDEFINED_VALUE) {
          throw new IllegalArgumentException("Wire does not allow an enum value of " + tag);
        }
        initializers.add(String.valueOf(tag));
        addEnumValueOptionInitializers(protoFile, value, options, mapMaker, initializers);

        writer.emitEnumValue(value.getName() + "(" + join(initializers, ", ") + ")",
            (i == count - 1));
      }

      if (generateOptions) {
        emitEnumOptions(protoFile, mapMaker.createEnumOptionsMap(protoFile, enumType));
      }

      // Output Private tag field
      writer.emitEmptyLine();
      writer.emitField("int", "value", EnumSet.of(PRIVATE, FINAL));

      // Output extension fields.
      for (EnumValueOptionInfo option : options) {
        writer.emitField(option.type, trailingSegment(option.name), EnumSet.of(PUBLIC, FINAL));
      }
      writer.emitEmptyLine();

      // Private Constructor
      List<String> parameters = new ArrayList<String>();
      parameters.add("int");
      parameters.add("value");
      for (EnumValueOptionInfo option : options) {
        parameters.add(option.type);
        parameters.add(trailingSegment(option.name));
      }

      writer.beginConstructor(EnumSet.of(PRIVATE), parameters, null);
      writer.emitStatement("this.value = value");
      for (EnumValueOptionInfo option : options) {
        String name = trailingSegment(option.name);
        writer.emitStatement("this.%s = %s", name, name);
      }
      writer.endConstructor();
      writer.emitEmptyLine();

      // Public Getter
      writer.emitAnnotation(Override.class);
      writer.beginMethod("int", "getValue", EnumSet.of(PUBLIC));
      writer.emitStatement("return value");
      writer.endMethod();
      writer.endType();
    }
  }

  private void emitEnumOptions(ProtoFile protoFile, Map<String, ?> optionsMap) throws IOException {
    if (optionsMap != null) {
      StringBuilder sb = new StringBuilder();
      sb.append("new EnumOptions.Builder()");
      for (Map.Entry<String, ?> entry : optionsMap.entrySet()) {
        String fqName = entry.getKey();
        ExtensionInfo info = getExtension(fqName);
        sb.append(String.format("%n.setExtension(Ext_%s.%s, %s)", info.location,
            getTrailingSegment(fqName),
            optionsMapMaker.createOptionInitializer(protoFile, entry.getValue(), "", "",
                info.fqType, false, 0)));
      }
      sb.append("\n.build()");
      writer.emitEmptyLine();
      writer.emitField("EnumOptions", "ENUM_OPTIONS", EnumSet.of(PUBLIC, STATIC, FINAL),
          sb.toString());
    }
  }

  private void emitAll(ProtoFile protoFile, MessageType messageType, Map<String, ?> optionsMap,
      boolean topLevel) throws IOException {
    Set<Modifier> modifiers = EnumSet.of(PUBLIC, FINAL);
    if (!topLevel) {
      modifiers.add(STATIC);
    }

    String name = messageType.getName();
    emitDocumentation(messageType.getDocumentation());
    writer.beginType(name, "class", modifiers,
        hasExtensions(messageType) ? "ExtendableMessage<" + name + ">" : "Message");

    emitMessageOptions(protoFile, optionsMap);
    if (generateOptions) {
      emitMessageFieldOptions(protoFile, messageType);
    }
    emitMessageFieldDefaults(protoFile, messageType);
    emitMessageFields(protoFile, messageType);
    emitMessageFieldsConstructor(protoFile, messageType);
    emitMessageBuilderConstructor(messageType);
    emitMessageEquals(messageType);
    emitMessageHashCode(messageType);
    emitBuilder(protoFile, messageType);
  }

  private void emitMessageOptions(ProtoFile protoFile, Map<String, ?> optionsMap)
      throws IOException {
    if (optionsMap != null) {
      StringBuilder sb = new StringBuilder();
      sb.append("new MessageOptions.Builder()");
      for (Map.Entry<String, ?> entry : optionsMap.entrySet()) {
        String fqName = entry.getKey();
        ExtensionInfo info = getExtension(fqName);
        sb.append(String.format("%n.setExtension(Ext_%s.%s, %s)", info.location,
            getTrailingSegment(fqName), optionsMapMaker.createOptionInitializer(protoFile,
                entry.getValue(), "", "", info.fqType, false, 0)));
      }
      sb.append("\n.build()");
      writer.emitEmptyLine();
      writer.emitField("MessageOptions", "MESSAGE_OPTIONS", EnumSet.of(PUBLIC, STATIC, FINAL),
          sb.toString());
    }
  }

  private void emitMessageFieldOptions(ProtoFile protoFile, MessageType messageType)
      throws IOException {
    Map<String, List<Option>> fieldOptions = new LinkedHashMap<>();

    for (MessageType.Field field : messageType.getFields()) {
      List<Option> options = new ArrayList<>(field.getOptions());
      for (Iterator<Option> iterator = options.iterator(); iterator.hasNext();) {
        // Remove non-custom key
        String name = iterator.next().getName();
        if (OptionsMapMaker.DEFAULT_FIELD_OPTION_KEYS.contains(name)) {
          iterator.remove();
        }
      }
      if (!options.isEmpty()) {
        fieldOptions.put(field.getName(), options);
      }
    }

    if (!fieldOptions.isEmpty()) {
      writer.emitEmptyLine();
    }

    for (Map.Entry<String, List<Option>> entry : fieldOptions.entrySet()) {
      Map<String, ?> fieldOptionsMap =
          optionsMapMaker.createFieldOptionsMap(protoFile, messageType, entry.getValue());
      emitFieldOptions(protoFile, entry.getKey(), fieldOptionsMap);
    }
  }

  private void emitFieldOptions(ProtoFile protoFile, String fieldName, Map<String, ?> optionsMap)
      throws IOException {
    if (optionsMap == null) return;

    StringBuilder sb = new StringBuilder();
    sb.append("new FieldOptions.Builder()");
    for (Map.Entry<String, ?> entry : optionsMap.entrySet()) {
      String fqName = entry.getKey();
      ExtensionInfo info = getExtension(fqName);
      if (info == null) {
        throw new WireCompilerException("No extension info for " + fqName);
      }
      sb.append(String.format("%n.setExtension(Ext_%s.%s, %s)", info.location,
          getTrailingSegment(fqName),
          optionsMapMaker.createOptionInitializer(protoFile, entry.getValue(), "", "", info.fqType,
              false, 0)));
    }
    sb.append("\n.build()");
    writer.emitField("FieldOptions", "FIELD_OPTIONS_" + fieldName.toUpperCase(Locale.US),
        EnumSet.of(PUBLIC, STATIC, FINAL), sb.toString());
  }

  // Example:
  //
  // public static final Integer DEFAULT_OPT_INT32 = 123;
  //
  private void emitMessageFieldDefaults(ProtoFile protoFile, MessageType messageType)
      throws IOException {
    List<MessageType.Field> defaultFields = new ArrayList<MessageType.Field>();
    for (MessageType.Field field : messageType.getFields()) {
      // Message types cannot have defaults
      if (!isMessageType(field.getType()) || FieldInfo.isRepeated(field)) {
        defaultFields.add(field);
      }
    }

    if (!defaultFields.isEmpty()) {
      writer.emitEmptyLine();
    }

    for (MessageType.Field field : defaultFields) {
      String javaName = getJavaFieldType(protoFile, field);
      if (javaName == null) {
        throw new WireCompilerException(
            "Unknown type for field " + field + " in message " + messageType.getName());
      }
      String defaultValue = getDefaultValue(protoFile, field);

      writer.emitField(javaName, "DEFAULT_" + field.getName().toUpperCase(Locale.US),
          EnumSet.of(PUBLIC, STATIC, FINAL), defaultValue);
    }
  }

  // Example:
  //
  // /**
  //  * An optional int32
  //  */
  // @ProtoField(
  //   tag = 1,
  //   type = INT32
  // )
  // public final Integer optional_int32;
  //
  private void emitMessageFields(ProtoFile protoFile, MessageType messageType) throws IOException {
    for (MessageType.Field field : messageType.getFields()) {
      int tag = field.getTag();

      String fieldType = field.getType();
      String javaName = javaName(protoFile, fieldType);
      Map<String, String> map = new LinkedHashMap<>();
      map.put("tag", String.valueOf(tag));

      boolean isEnum = false;
      if (TypeInfo.isScalar(fieldType)) {
        map.put("type", scalarTypeConstant(fieldType));
      } else {
        isEnum = isEnum(field.getType());
        if (isEnum) map.put("type", "ENUM");
      }

      if (!FieldInfo.isOptional(field)) {
        if (FieldInfo.isPacked(field, isEnum)) {
          map.put("label", "PACKED");
        } else {
          map.put("label", field.getLabel().toString());
        }
      }

      if (field.isDeprecated()) {
        map.put("deprecated", "true");
      }

      // Scan for redacted fields.
      for (Option option : field.getOptions()) {
        // We allow any package name to be used as long as it ends with '.redacted'.
        if (isRedacted(option)) {
          map.put("redacted", "true");
          break;
        }
      }

      writer.emitEmptyLine();
      emitDocumentation(field.getDocumentation());
      writer.emitAnnotation(ProtoField.class, map);

      if (field.isDeprecated()) {
        writer.emitAnnotation(Deprecated.class);
      }

      if (FieldInfo.isRepeated(field)) javaName = "List<" + javaName + ">";
      writer.emitField(javaName, sanitize(field.getName()), EnumSet.of(PUBLIC, FINAL));
    }
  }

  // Example:
  //
  // public SimpleMessage(int optional_int32, long optional_int64) {
  //   this.optional_int32 = optional_int32;
  //   this.optional_int64 = optional_int64;
  // }
  //
  private void emitMessageFieldsConstructor(ProtoFile protoFile, MessageType messageType)
      throws IOException {
    List<String> params = new ArrayList<>();
    for (MessageType.Field field : messageType.getFields()) {
      String javaName = getJavaFieldType(protoFile, field);
      params.add(javaName);
      params.add(sanitize(field.getName()));
    }

    writer.emitEmptyLine();
    writer.beginMethod(null, messageType.getName(), EnumSet.of(PUBLIC), params, null);
    for (MessageType.Field field : messageType.getFields()) {
      String sanitizedName = sanitize(field.getName());
      if (FieldInfo.isRepeated(field)) {
        writer.emitStatement("this.%1$s = immutableCopyOf(%1$s)", sanitizedName);
      } else {
        writer.emitStatement("this.%1$s = %1$s", sanitizedName);
      }
    }
    writer.endMethod();
  }

  // Example:
  //
  // private SimpleMessage(Builder builder) {
  //   this(builder.optional_int32, builder.optional_int64);
  //   setBuilder(builder);
  // }
  //
  private void emitMessageBuilderConstructor(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginMethod(null, messageType.getName(), EnumSet.of(PRIVATE), "Builder", "builder");
    StringBuilder params = new StringBuilder();
    for (MessageType.Field field : messageType.getFields()) {
      if (params.length() > 0) {
        params.append(", ");
      }
      params.append("builder.");
      params.append(sanitize(field.getName()));
    }
    if (params.length() > 0) {
      writer.emitStatement("this(%1$s)", params);
    }
    writer.emitStatement("setBuilder(builder)");
    writer.endMethod();
  }

  // Example:
  //
  // @Override
  // public boolean equals(Object other) {
  //   if (other == this) return true;
  //   if (!(other instanceof SimpleMessage)) return false;
  //   SimpleMessage o = (SimpleMessage) other;
  //   if (!Wire.equals(optional_int32, o.optional_int32)) return false;
  //   return true;
  //
  private void emitMessageEquals(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("boolean", "equals", EnumSet.of(PUBLIC), "Object", "other");

    List<MessageType.Field> fields = messageType.getFields();
    if (fields.isEmpty()) {
      writer.emitStatement("return other instanceof %s", messageType.getName());
    } else {
      writer.emitStatement("if (other == this) return true");
      writer.emitStatement("if (!(other instanceof %s)) return false", messageType.getName());
      if (hasOnlyOneField(messageType)) {
        String name = sanitize(fields.get(0).getName());
        // If the field is named "other" or "o", qualify the field reference with 'this'
        writer.emitStatement("return equals(%1$s, ((%2$s) other).%3$s)",
            addThisIfOneOf(name, "other", "o"), messageType.getName(), name);
      } else {
        writer.emitStatement("%1$s o = (%1$s) other", messageType.getName());
        if (hasExtensions(messageType)) {
          writer.emitStatement("if (!extensionsEqual(o)) return false");
        }
        StringBuilder sb = new StringBuilder();
        String prefix = "return ";
        for (MessageType.Field field : fields) {
          sb.append(prefix);
          prefix = "\n&& ";
          // If the field is named "other" or "o", qualify the field reference with 'this'
          String name = sanitize(field.getName());
          sb.append(String.format("equals(%1$s, o.%2$s)",
              addThisIfOneOf(name, "other", "o"), name));
        }
        writer.emitStatement(sb.toString());
      }
    }
    writer.endMethod();
  }

  // Example:
  //
  // @Override
  // public int hashCode() {
  //   if (hashCode == 0) {
  //     int result = super.extensionsHashCode();
  //     result = result * 37 + (f != null ? f.hashCode() : 0);
  //     hashCode = result;
  //   }
  //   return hashCode;
  // }
  //
  // For repeated fields, the final "0" in the example above changes to a "1"
  // in order to be the same as the system hash code for an empty list.
  //
  private void emitMessageHashCode(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("int", "hashCode", EnumSet.of(PUBLIC));

    if (!hasFields(messageType) && !hasExtensions(messageType)) {
      writer.emitStatement("return 0");
    } else if (hasOnlyOneField(messageType)) {
      MessageType.Field field = messageType.getFields().get(0);
      String name = sanitize(field.getName());
      // If the field is named "result", qualify the field reference with 'this'
      name = addThisIfOneOf(name, "result");
      writer.emitStatement("int result = hashCode");
      writer.emitStatement(
          "return result != 0 ? result : (hashCode = %1$s != null ? %1$s.hashCode() : %2$s)", name,
          nullHashValue(field));
    } else {
      writer.emitStatement("int result = hashCode");
      writer.beginControlFlow("if (result == 0)");
      boolean afterFirstAssignment = false;
      if (hasExtensions(messageType)) {
        writer.emitStatement("result = extensionsHashCode()");
        afterFirstAssignment = true;
      }
      for (MessageType.Field field : messageType.getFields()) {
        String name = sanitize(field.getName());
        // If the field is named "result", qualify the field reference with 'this'
        name = addThisIfOneOf(name, "result");
        if (afterFirstAssignment) {
          writer.emitStatement("result = result * 37 + (%1$s != null ? %1$s.hashCode() : %2$s)",
              name, nullHashValue(field));
        } else {
          writer.emitStatement("result = %1$s != null ? %1$s.hashCode() : %2$s", name,
              nullHashValue(field));
          afterFirstAssignment = true;
        }
      }
      writer.emitStatement("hashCode = result");
      writer.endControlFlow();
      writer.emitStatement("return result");
    }
    writer.endMethod();
  }

  private void emitBuilder(ProtoFile protoFile, MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginType("Builder", "class", EnumSet.of(PUBLIC, STATIC, FINAL),
        (hasExtensions(messageType) ? "ExtendableBuilder<" : "Message.Builder<")
            + messageType.getName()
            + ">");
    emitBuilderFields(protoFile, messageType);
    emitBuilderConstructors(messageType);
    emitBuilderSetters(protoFile, messageType);
    if (hasExtensions(messageType)) emitBuilderSetExtension(messageType);
    emitBuilderBuild(messageType);
    writer.endType();
  }

  private void emitBuilderFields(ProtoFile protoFile, MessageType messageType) throws IOException {
    List<MessageType.Field> fields = messageType.getFields();

    if (!fields.isEmpty()) writer.emitEmptyLine();
    for (MessageType.Field field : fields) {
      String javaName = getJavaFieldType(protoFile, field);
      writer.emitField(javaName, sanitize(field.getName()), EnumSet.of(PUBLIC));
    }
  }

  // Example:
  //
  // public Builder() {
  // }
  //
  // public Builder(SimpleMessage message) {
  //   super(message);
  //   if (message == null) return;
  //   this.optional_int32 = message.optional_int32;
  //   ...
  // }
  //
  private void emitBuilderConstructors(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginMethod(null, "Builder", EnumSet.of(PUBLIC));
    writer.endMethod();

    writer.emitEmptyLine();
    writer.beginMethod(null, "Builder", EnumSet.of(PUBLIC), messageType.getName(), "message");
    writer.emitStatement("super(message)");
    List<MessageType.Field> fields = messageType.getFields();
    if (!fields.isEmpty()) writer.emitStatement("if (message == null) return");
    for (MessageType.Field field : fields) {
      if (FieldInfo.isRepeated(field)) {
        writer.emitStatement("this.%1$s = copyOf(message.%1$s)",
            sanitize(field.getName()));
      } else {
        writer.emitStatement("this.%1$s = message.%1$s", sanitize(field.getName()));
      }
    }
    writer.endMethod();
  }

  private void emitBuilderSetters(ProtoFile protoFile, MessageType messageType) throws IOException {
    for (MessageType.Field field : messageType.getFields()) {
      String javaName = getJavaFieldType(protoFile, field);
      List<String> args = new ArrayList<String>();
      args.add(javaName);
      String sanitized = sanitize(field.getName());
      args.add(sanitized);

      writer.emitEmptyLine();

      emitDocumentation(field.getDocumentation());

      if (field.isDeprecated()) {
        writer.emitAnnotation(Deprecated.class);
      }

      writer.beginMethod("Builder", sanitized, EnumSet.of(PUBLIC), args, null);
      boolean isEnum = isEnum(field.getType());
      if (FieldInfo.isRepeated(field)) {
        if (isEnum) {
          writer.emitStatement("this.%1$s = checkForNullOrUndefined(%1$s)", sanitized);
        } else {
          writer.emitStatement("this.%1$s = checkForNulls(%1$s)", sanitized);
        }
      } else {
        if (isEnum) {
          writer.emitStatement("if (%s == %s.__UNDEFINED__) throw new IllegalArgumentException()",
              sanitized, javaName);
        }
        writer.emitStatement("this.%1$s = %1$s", sanitized);
      }
      writer.emitStatement("return this");
      writer.endMethod();
    }
  }

  // Example:
  //
  // @Override
  // public <E> Builder setExtension(Extension<ExternalMessage, E> extension, E value) {
  //   super.setExtension(extension, value);
  //   return this;
  // }
  //
  private void emitBuilderSetExtension(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("<E> Builder", "setExtension", EnumSet.of(PUBLIC),
        "Extension<" + messageType.getName() + ", E>", "extension", "E", "value");
    writer.emitStatement("super.setExtension(extension, value)");
    writer.emitStatement("return this");
    writer.endMethod();
  }

  // Example:
  //
  // @Override
  // public SimpleMessage build() {
  //   checkRequiredFields();
  //   return new SimpleMessage(this);
  // }
  //
  // The call to checkRequiredFields will be emitted only if the message has
  // required fields.
  //
  private void emitBuilderBuild(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod(messageType.getName(), "build", EnumSet.of(PUBLIC));
    if (hasRequiredFields(messageType)) {
      writer.emitStatement("checkRequiredFields()");
    }
    writer.emitStatement("return new %s(this)", messageType.getName());
    writer.endMethod();
  }

  private void emitServiceInterface(ProtoFile protoFile, Service service) throws IOException {
    if (serviceWriterConstructor == null) return;

    try {
      writer = io.getJavaWriter(outputDirectory, getJavaPackage(protoFile), service.getName());
      ServiceWriter serviceWriter;
      try {
        serviceWriter = (ServiceWriter) serviceWriterConstructor.newInstance(writer,
            serviceWriterOptions);
      } catch (Exception e) {
        throw new IllegalStateException(
            "Unable to construct an instance of " + serviceWriterConstructor.getDeclaringClass()
                .getName() + ": " + e);
      }

      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", protoFile.getFileName());
      writer.emitPackage(getJavaPackage(protoFile));

      Set<String> imports = new LinkedHashSet<>();
      List<String> externalTypes = new ArrayList<>();
      getExternalTypes(service, externalTypes);
      imports.addAll(externalTypes);

      serviceWriter.emitService(service, imports);
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void getExternalTypes(Service service, List<String> types) {
    for (Service.Method method : service.getMethods()) {
      addType(method.getRequestType(), types);
      addType(method.getResponseType(), types);
    }
  }

  private void addType(String method, List<String> types) {
    String fqName = javaSymbolMap.get(method);
    if (fullyQualifiedNameIsOutsidePackage(fqName)) {
      types.add(fqName);
    }
  }

  private void populateJavaSymbolMap(List<Type> types, String javaPrefix) {
    for (Type type : types) {
      String name = type.getName();
      String fqName = type.getFullyQualifiedName();
      javaSymbolMap.put(fqName, javaPrefix + name);
      populateJavaSymbolMap(type.getNestedTypes(), javaPrefix + name + ".");
    }
  }

  private void getExternalTypes(Type parent, Set<String> types) {
    if (parent instanceof MessageType) {
      MessageType messageType = (MessageType) parent;
      for (MessageType.Field field : messageType.getFields()) {
        String fqName = javaSymbolMap.get(field.getType());
        if (fqName == null) {
          continue;
        }
        if (fullyQualifiedNameIsOutsidePackage(fqName)) {
          types.add(fqName);
        }
        String parentType = removeTrailingSegment(fqName);
        if (javaTypeIsComplete(parentType) && fullyQualifiedNameIsOutsidePackage(parentType)) {
          types.add(parentType);
        }
      }
    }
    for (Type nestedType : parent.getNestedTypes()) {
      getExternalTypes(nestedType, types);
    }
  }

  private boolean javaTypeIsComplete(String type) {
    if (javaSymbols.isEmpty()) {
      javaSymbols.addAll(javaSymbolMap.values());
    }
    return javaSymbols.contains(type);
  }

  private String protoFileName(String path) {
    int slashIndex = path.lastIndexOf('/');
    if (slashIndex != -1) {
      path = path.substring(slashIndex + 1);
    }
    if (path.endsWith(".proto")) {
      path = path.substring(0, path.length() - ".proto".length());
    }
    return path;
  }

  /** Works for messages or Java classes. */
  private static boolean isOptionType(String fullyQualifiedName) {
    return (isMessageOptions(fullyQualifiedName) || isFieldOptions(fullyQualifiedName));
  }

  /** Works for messages or Java classes. */
  private static boolean isFieldOptions(String name) {
    return "google.protobuf.FieldOptions".equals(name) || "com.google.protobuf.FieldOptions".equals(
        name);
  }

  /** Works for messages or Java classes. */
  private static boolean isMessageOptions(String fullyQualifiedName) {
    return "google.protobuf.MessageOptions".equals(fullyQualifiedName)
        || "com.google.protobuf.MessageOptions".equals(fullyQualifiedName);
  }

  private boolean hasExtends(ProtoFile protoFile) {
    List<ExtendDeclaration> declarations = protoFile.getExtendDeclarations();
    if (!generateOptions) {
      for (ExtendDeclaration declaration : declarations) {
        String name = declaration.getFullyQualifiedName();
        if (!isFieldOptions(name) && !isMessageOptions(name)) {
          return true;
        }
      }
    }
    return !declarations.isEmpty();
  }

  private boolean hasByteStringExtension(ProtoFile protoFile) {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      for (MessageType.Field field : extend.getFields()) {
        String fieldType = field.getType();
        if ("bytes".equals(fieldType)) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean hasRepeatedExtension(ProtoFile protoFile) {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      for (MessageType.Field field : extend.getFields()) {
        if (field.getLabel() == MessageType.Label.REPEATED) {
          return true;
        }
      }
    }
    return false;
  }

  private List<String> getExtensionTypes(ProtoFile protoFile) {
    List<String> extensionClasses = new ArrayList<>();
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      String extendFullyQualifiedName = javaSymbolMap.get(extend.getFullyQualifiedName());
      if (fullyQualifiedNameIsOutsidePackage(extendFullyQualifiedName)) {
        extensionClasses.add(extendFullyQualifiedName);
      }
      for (MessageType.Field field : extend.getFields()) {
        String fieldType = javaSymbolMap.get(field.getType());
        if (fullyQualifiedNameIsOutsidePackage(fieldType)) {
          extensionClasses.add(fieldType);
        }
      }
    }
    return extensionClasses;
  }

  boolean fullyQualifiedNameIsOutsidePackage(String fqName) {
    return fqName != null && !javaPackage.equals(getPackageFromFullyQualifiedJavaName(fqName));
  }

  String prefixWithPackageName(ProtoFile protoFile, String name) {
    return protoFile.getPackageName() + "." + name;
  }

  private String getLabelString(MessageType.Field field, boolean isEnum) {
    switch (field.getLabel()) {
      case OPTIONAL:
        return "Optional";
      case REQUIRED:
        return "Required";
      case REPEATED:
        return FieldInfo.isPacked(field, isEnum) ? "Packed" : "Repeated";
      default:
        throw new WireCompilerException("Unknown extension label \"" + field.getLabel() + "\"");
    }
  }

  private void emitDocumentation(String documentation) throws IOException {
    if (hasDocumentation(documentation)) {
      writer.emitJavadoc(sanitizeJavadoc(documentation));
    }
  }

  /**
   * A grab-bag of fixes for things that can go wrong when converting to javadoc.
   */
  private String sanitizeJavadoc(String documentation) {
    // JavaWriter will pass the doc through String.format, so escape all '%' chars
    documentation = documentation.replace("%", "%%");
    // Remove trailing whitespace on each line.
    documentation = documentation.replaceAll("[^\\S\n]+\n", "\n");
    documentation = documentation.replaceAll("\\s+$", "");
    // Rewrite '@see <url>' to use an html anchor tag
    documentation =
        documentation.replaceAll("@see (http:" + URL_CHARS + "+)", "@see <a href=\"$1\">$1</a>");
    return documentation;
  }

  private boolean hasDocumentation(String documentation) {
    return documentation != null && !documentation.isEmpty();
  }

  // Ensure a non-null value for the Java package name.
  String getJavaPackage(ProtoFile protoFile) {
    Option javaPackage = Option.findByName(protoFile.getOptions(), "java_package");
    if (javaPackage != null) {
      return (String) javaPackage.getValue();
    }
    return protoFile.getPackageName() == null ? "" : protoFile.getPackageName();
  }

  boolean isEnum(String typeName) {
    return enumTypes.containsKey(typeName);
  }

  private String getEnumDefault(String typeName) {
    return enumTypes.get(typeName);
  }

  private boolean hasExtensions(MessageType messageType) {
    return !messageType.getExtensions().isEmpty();
  }

  private boolean hasFields(Type type) {
    return type instanceof MessageType && !((MessageType) type).getFields().isEmpty();
  }

  private boolean hasRequiredFields(Type type) {
    if (type instanceof MessageType) {
      for (MessageType.Field field : ((MessageType) type).getFields()) {
        if (FieldInfo.isRequired(field)) return true;
      }
    }
    return false;
  }

  /**
   * Returns the name of the {@code Message} type constant (e.g.,
   * {@code INT32} or {@code STRING}) associated
   * with the given scalar type (e.g., {@code int32} or {@code string}).
   */
  private String scalarTypeConstant(String type) {
    return type.toUpperCase(Locale.US);
  }

  private boolean isRedacted(Option option) {
    return option.getName().endsWith(".redacted") && "true".equals(option.getValue());
  }

  private String sanitize(String name) {
    return TypeInfo.JAVA_KEYWORDS.contains(name) ? "_" + name : name;
  }

  private String getDefaultValue(ProtoFile protoFile, MessageType.Field field) {
    String initialValue = field.getDefault();
    if (FieldInfo.isRepeated(field)) return "Collections.emptyList()";
    String javaName = javaName(protoFile, field.getType());
    if (TypeInfo.isScalar(field.getType())) {
      return getInitializerForType(initialValue, javaName);
    } else {
      if (initialValue != null) {
        return javaName + "." + initialValue;
      } else {
        if (isEnum(field.getType())) {
          return javaName + "." + getEnumDefault(field.getType());
        } else {
          throw new WireCompilerException("Field " + field + " cannot have default value");
        }
      }
    }
  }

  String getInitializerForType(String initialValue, String javaTypeName) {
    switch (javaTypeName) {
      case "Boolean":
        return initialValue == null ? "false" : initialValue;
      case "Integer":
        // Wrap unsigned values
        return initialValue == null ? "0" : toInt(initialValue);
      case "Long":
        // Wrap unsigned values and add an 'L'
        return initialValue == null ? "0L" : toLong(initialValue) + "L";
      case "Float":
        return initialValue == null ? "0F" : initialValue + "F";
      case "Double":
        return initialValue == null ? "0D" : initialValue + "D";
      case "String":
        return quoteString(initialValue);
      case "ByteString":
        if (initialValue == null) {
          return "ByteString.EMPTY";
        } else {
          return "ByteString.decodeBase64(\"" + ByteString.of(initialValue.getBytes(ISO_8859_1))
              .base64() + "\")";
        }
      default:
        throw new WireCompilerException(javaTypeName + " is not an allowed scalar type");
    }
  }

  private String toInt(String value) {
    return Integer.toString(new BigDecimal(value).intValue());
  }

  private String toLong(String value) {
    return Long.toString(new BigDecimal(value).longValue());
  }

  private String quoteString(String initialValue) {
    return initialValue == null ? "\"\"" : JavaWriter.stringLiteral(initialValue);
  }

  private boolean isMessageType(String fieldType) {
    return !TypeInfo.isScalar(fieldType) && !isEnum(fieldType);
  }

  private boolean hasOnlyOneField(MessageType messageType) {
    return messageType.getFields().size() == 1 && !hasExtensions(messageType);
  }

  private String addThisIfOneOf(String name, String... matches) {
    for (String match : matches) {
      if (match.equals(name)) {
        return "this." + name;
      }
    }
    return name;
  }

  private int nullHashValue(MessageType.Field field) {
    return FieldInfo.isRepeated(field) ? 1 : 0;
  }

  private String getJavaFieldType(ProtoFile protoFile, MessageType.Field field) {
    String javaName = javaName(protoFile, field.getType());
    if (FieldInfo.isRepeated(field)) javaName = "List<" + javaName + ">";
    return javaName;
  }

  String fullyQualifiedJavaName(String typeName) {
    String scalarType = TypeInfo.scalarType(typeName);
    return scalarType != null ? scalarType : javaSymbolMap.get(typeName);
  }

  String javaName(ProtoFile protoFile, String typeName) {
    String scalarType = TypeInfo.scalarType(typeName);
    return scalarType != null ? scalarType : shortenJavaName(protoFile, javaSymbolMap.get(typeName));
  }

  String javaNameNoScope(ProtoFile protoFile, String typeName) {
    String scalarType = TypeInfo.scalarType(typeName);
    return scalarType != null ? scalarType : shortenJavaName(protoFile, javaSymbolMap.get(typeName));
  }

  String shortenJavaName(ProtoFile protoFile, String fullyQualifiedName) {
    if (fullyQualifiedName == null) return null;
    String javaTypeBeingGenerated = getJavaPackage(protoFile) + "." + typeBeingGenerated;
    if (fullyQualifiedName.startsWith(javaTypeBeingGenerated)) {
      return fullyQualifiedName.substring(javaTypeBeingGenerated.length());
    }

    // Dependencies in javaSymbolMap are already imported.
    for (String javaSymbol : javaSymbolMap.values()) {
      if (fullyQualifiedName.startsWith(javaSymbol)) {
        // omit package part
        String pkgPrefix = getPackageFromFullyQualifiedJavaName(fullyQualifiedName) + '.';
        return fullyQualifiedName.substring(pkgPrefix.length());
      }
    }

    return fullyQualifiedName;
  }

  private String getPackageFromFullyQualifiedJavaName(String fqName) {
    while (javaSymbolMap.containsValue(fqName)) {
      fqName = removeTrailingSegment(fqName);
    }
    return fqName;
  }

  private void addNullEnumValueOptionInitializers(ProtoFile protoFile, EnumType.Value value,
      List<EnumValueOptionInfo> optionInfo, OptionsMapMaker mapMaker, List<String> initializers) {
    addEnumValueOptionInitializers(protoFile, value, optionInfo, mapMaker, initializers);
    for (int i = 1; i < initializers.size(); i++) {
      initializers.set(i, "null");
    }
  }

  private List<EnumValueOptionInfo> getEnumValueOptions(ProtoFile protoFile, EnumType enumType,
      OptionsMapMaker mapMaker) {
    if (!generateOptions && enumOptions.isEmpty()) {
      return Collections.emptyList();
    }

    Map<String, ?> optionsMap = mapMaker.createEnumValueOptionsMap(protoFile, enumType);
    if (optionsMap == null || optionsMap.isEmpty()) {
      return Collections.emptyList();
    }

    List<EnumValueOptionInfo> result = new ArrayList<>();

    Set<String> optionNames = new TreeSet<String>();
    for (EnumType.Value value : enumType.getValues()) {
      for (Option option : value.getOptions()) {
        optionNames.add(option.getName());
      }
    }

    Set<String> fqNames = optionsMap.keySet();
    for (String optionName : optionNames) {
      for (String fqName : fqNames) {
        if (fqName.equals(optionName) || fqName.endsWith("." + optionName)) {
          if (enumOptions.contains(fqName)) {
            ExtensionInfo info = getExtension(fqName);
            result.add(new EnumValueOptionInfo(javaName(protoFile, info.fqType), optionName));
          }
        }
      }
    }

    return result;
  }

  private void addEnumValueOptionInitializers(ProtoFile protoFile, EnumType.Value value,
      List<EnumValueOptionInfo> optionInfo, OptionsMapMaker mapMaker, List<String> initializers) {
    Map<String, ?> enumValueOptionsMap = mapMaker.createSingleEnumValueOptionMap(protoFile, value);
    List<Option> valueOptions = value.getOptions();
    for (EnumValueOptionInfo option : optionInfo) {
      Option optionByName = Option.findByName(valueOptions, option.name);
      String initializer = null;
      if (optionByName != null) {
        for (Map.Entry<String, ?> entry : enumValueOptionsMap.entrySet()) {
          String fqName = entry.getKey();
          ExtensionInfo info = getExtension(fqName);
          String name = optionByName.getName();
          if (fqName.equals(name) || fqName.endsWith("." + name)) {
            initializer = mapMaker.createOptionInitializer(protoFile, entry.getValue(), "", "",
                info.fqType, false, 1);
            break;
          }
        }
      }
      initializers.add(initializer);
    }
  }

  ExtensionInfo getExtension(String name) {
    return extensionInfo.get(name);
  }

  FieldInfo getField(String dollarName) {
    return fieldMap.get(dollarName);
  }

  private String trailingSegment(String s) {
    int index = s.lastIndexOf('.');
    return index == -1 ? s : s.substring(index + 1);
  }

  String getTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? name : name.substring(index + 1);
  }

  private String removeTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? "" : name.substring(0, index);
  }

  private String join(List<String> values, String separator) {
    StringBuilder sb = new StringBuilder();
    String sep = "";
    for (String value : values) {
      sb.append(sep);
      sb.append(value);
      sep = separator;
    }
    return sb.toString();
  }
}
