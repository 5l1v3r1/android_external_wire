package com.squareup.wire.compiler.plugin.java;

import com.squareup.protoparser.ProtoFile;
import com.squareup.wire.compiler.Filesystem;
import com.squareup.wire.compiler.plugin.WirePlugin;
import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.squareup.wire.compiler.plugin.java.Util.getJavaFile;

/**
 * TODO doc me!
 * <p>
 * The API of this class is meant to mimic the builder pattern and should be used as such.
 */
public class WireJavaPlugin implements WirePlugin {
  static final String FILE_HEADER = "Code generated by Wire protocol buffer compiler. Do not edit.";
  private static final String ARG_OUT = "--out=";
  private static final String ARG_REGISTRY = "--registry=";
  private static final String ARG_NO_OPTIONS = "--no-options";

  private final Filesystem fs;

  private File outputDirectory;
  private String registryClass;
  private boolean generateOptions = true;

  public WireJavaPlugin() {
    this(Filesystem.SYSTEM);
  }

  WireJavaPlugin(Filesystem fs) {
    this.fs = fs;
  }

  /** Directory into which generated code will be placed. */
  public WireJavaPlugin setOutputDirectory(File outputDirectory) {
    checkNotNull(outputDirectory, "Output directory must not be null.");
    this.outputDirectory = outputDirectory;
    return this;
  }

  /**
   * A fully-qualified Java class name which will be generated containing a constant list of all
   * extension classes. This list is suitable for passing to
   * {@link com.squareup.wire.Wire#Wire(List) Wire's constructor} at runtime for constructing its
   * internal extension registry.
   */
  public WireJavaPlugin setRegistryClass(String registryClass) {
    checkNotNull(registryClass, "Registry class must not be null.");
    checkArgument(!registryClass.trim().isEmpty(), "Registry class must not be blank.");
    this.registryClass = registryClass;
    return this;
  }

  /**
   * Control whether code will be emitted for options on messages and fields. The presence of
   * options on a message will result in a static member named {@code MESSAGE_OPTIONS}, initialized
   * with the options and their values. The presence of options on a field (other than the standard
   * options "default", "deprecated", and "packed") will result in a static member named
   * {@code FIELD_OPTIONS_&lt;field name>} in the generated code, initialized with the field option
   * values.
   */
  public WireJavaPlugin setGenerateOptions(boolean generateOptions) {
    this.generateOptions = generateOptions;
    return this;
  }

  @Override public void parseArgs(List<String> args) {
    for (String arg : args) {
      if (arg.equals(ARG_NO_OPTIONS)) {
        setGenerateOptions(false);
      } else if (arg.startsWith(ARG_REGISTRY)) {
        String registryArg = arg.substring(ARG_REGISTRY.length());
        setRegistryClass(registryArg);
      } else if (arg.startsWith(ARG_OUT)) {
        String outArg = arg.substring(ARG_OUT.length());
        setOutputDirectory(new File(outArg));
      } else {
        throw new IllegalArgumentException("Unknown argument: " + arg);
      }
    }
  }

  @Override public void run(Set<ProtoFile> protoFiles) throws IOException {
    checkNotNull(outputDirectory, "Output directory must be specified.");

    generateTypes(protoFiles);
    Set<String> extensionClasses = generateExtensions(protoFiles);
    generateExtensionRegistry(extensionClasses);
  }

  private void generateTypes(Set<ProtoFile> protoFiles) {
    throw new UnsupportedOperationException("Not implemented."); // TODO
  }

  private Set<String> generateExtensions(Set<ProtoFile> protoFiles) {
    return new LinkedHashSet<String>();
  }

  private void generateExtensionRegistry(Set<String> extensionClasses) throws IOException {
    if (registryClass != null) {
      File registryClassFile = getJavaFile(outputDirectory, registryClass);
      Writer registryClassWriter = fs.writerUtf8(registryClassFile);
      ExtensionRegistryWriter writer = new ExtensionRegistryWriter(extensionClasses, registryClass);
      writer.write(registryClassWriter);
    }
  }
}
